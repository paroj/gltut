<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.0/gh-fork-ribbon.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/zenburn.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/glsl.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script><script>
            hljs.configure({"languages": ["c++", "glsl"]})
            $(document).ready(function() {
              $('pre').each(function(i, block) {
                hljs.highlightBlock(block);
              });
            });
        </script><title>Glossary</title><link rel="stylesheet" type="text/css" href="../chunked.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="../index.html" title="Learning Modern 3D Graphics Programming"><link rel="up" href="Tutorial%2004.html" title="Chapter 4. Objects at Rest"><link rel="prev" href="Tut04%20In%20Review.html" title="In Review"><link rel="next" href="Tutorial%2005.html" title="Chapter 5. Objects in Depth"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Glossary</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="Tut04%20In%20Review.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Objects at Rest</th><td width="20%" align="right"> <a accesskey="n" href="Tutorial%2005.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Tut04_Glossary"></a>Glossary</h2></div></div></div>
        
        
        <div class="glosslist"><dl><dt><span class="glossterm">face culling</span></dt><dd class="glossdef"><p>The ability to cull triangles based on the winding order of the triangle.
                        This functionality is activated in OpenGL by using
                            <code class="function">glEnable</code> with <code class="literal">GL_CULL_FACE</code>.
                        Which faces get culled is determined by the <code class="function">glCullFace</code>
                        and <code class="function">glFrontFace</code> functions.</p></dd><dt><span class="glossterm">winding order</span></dt><dd class="glossdef"><p>The order, clockwise or counter-clockwise, that the 3 vertices that make
                        up a triangle are received in. This is measured in window coordinates,
                        two-dimensionally.</p></dd><dt><span class="glossterm">projection</span></dt><dd class="glossdef"><p>The act of taking a series of objects in a higher dimension and presenting
                        those objects in a lower dimension. The act of rendering a 3D scene to a 2D
                        image requires projecting that scene from three dimensions into two
                        dimensions.</p><p>Projection always happens relative to a surface of projection. Projecting
                        2D space onto a 1D space requires a finite line to be projected on.
                        Projecting 3D space onto 2D space requires a plane of projection. This
                        surface is defined in the higher dimension's world.</p></dd><dt><span class="glossterm">orthographic projection</span></dt><dd class="glossdef"><p>A form of projection that simply negates all offsets in the direction
                        perpendicular to the surface of projection. When doing a 3D-to-2D
                        orthographic projection, if the plane is axis-aligned, then the projection
                        can be done simply. The coordinate that is perpendicular to the plane of
                        projection is simply discarded. If the plane is not axis-aligned, then the
                        math is more complex, but it has the same effect.</p><p>Orthographic projections are uniform in the direction of the projection.
                        Because of the uniformity, lines that are parallel in the higher dimensional
                        space are guaranteed to remain parallel in the lower dimensional space.</p></dd><dt><span class="glossterm">perspective projection</span></dt><dd class="glossdef"><p>A form of projection that projects onto the surface based on a position,
                        the eye position. Perspective projections attempt to emulate a pin-hole
                        camera model, which is similar to how human eyes see. The positions of
                        objects in space are projected onto the surface of projection radially, based
                        on the eye position.</p><p>Parallel lines in the higher dimension are <span class="emphasis"><em>not</em></span>
                        guaranteed to remain parallel in the lower dimension. They might, but they
                        might not.</p></dd><dt><span class="glossterm">frustum</span></dt><dd class="glossdef"><p>Geometrically, a frustum is 3D shape; a pyramid that has the top chopped
                        off. The view of a 3D-to-2D perspective projection, from the eye through the
                        plane of projection, has the shape of a frustum.</p></dd><dt><span class="glossterm">perspective divide</span></dt><dd class="glossdef"><p>A new name for the transformation from clip space to normalized device
                        coordinate space. This is so called because the division by W is what allows
                        perspective projection to work using only matrix math; a matrix alone would
                        not otherwise be able to perform the full perspective projection
                        operation.</p></dd><dt><span class="glossterm">camera space</span></dt><dd class="glossdef"><p>An arbitrarily defined, but highly useful, space from which the
                        perspective projection can be performed relatively easily. Camera space is
                        an infinitely large space, with positive X going right, positive Y going up,
                        and positive Z coming towards the viewer.</p><p>In camera space, the eye position of the perspective projection is assumed
                        to be at (0, 0, 1), and the plane of projection is a [-1, 1] plane in X and
                        Y, which passes through the 3D origin. Thus, all points that have a positive
                        Z are considered to be behind the camera and thus out of view. Positions in
                        camera space are defined relative to the camera's location, since the camera
                        has a fixed point of origin.</p></dd><dt><span class="glossterm">camera zNear, camera zFar</span></dt><dd class="glossdef"><p>Normalized device coordinate (NDC) space is bounded in all dimensions on
                        the range [-1, 1]. Camera space is unbounded, but the perspective transform
                        implicitly bounds what is considered in view to [-1, 1] in the X and Y axis.
                        This leaves the Z axis unbounded, which NDC space does not allow.</p><p>The camera zNear and zFar values are numbers that define the minimum and
                        maximum extent of Z in the perspective projection transform. These values
                        are positive, though they represent negative values in camera space.
                        Using the standard perspective transform, both values must be greater than
                        0, and zNear must be less than zFar.</p></dd><dt><span class="glossterm">swizzle selection</span></dt><dd class="glossdef"><p>Swizzle selection is a vector technique, unique to shading languages, that
                        allows you to take a vector and arbitrarily build other vectors from the
                        components. This selection is completely arbitrary; you can build a vec4
                        from a vec2, or any other combination you wish, up to 4 elements.</p><p>Swizzle selections use combinations of <span class="quote">“<span class="quote">x,</span>”</span>
                        <span class="quote">“<span class="quote">y,</span>”</span>
                        <span class="quote">“<span class="quote">z,</span>”</span> and <span class="quote">“<span class="quote">w</span>”</span> to pick components out of the input
                        vector. Swizzle operations look like this:</p><pre class="programlisting">vec2 firstVec;
vec4 secondVec = firstVec.xyxx;
vec3 thirdVec = secondVec.wzy;</pre><p>Swizzle selection is, in graphics hardware, considered an operation so
                        fast as to be instantaneous. That is, graphics hardware is built with
                        swizzle selection in mind.</p></dd><dt><span class="glossterm">matrix</span></dt><dd class="glossdef"><p>A two-dimensional arrangement of numbers. Like vectors, matrices can be
                        considered a single element. Matrices are often used to represent the
                        coefficients in a system of linear equations; because of this (among other
                        things), matrix math is often called linear algebra.</p><p>The size of a matrix, the number of columns and rows (denoted as NxM,
                        where N is the number of columns and M is the number of rows) determines the
                        kind of matrix. Matrix arithmetic has specific requirements on the two
                        matrices involved, depending on the arithmetic operation. Multiplying two
                        matrices together can only be performed if the number of rows in the matrix
                        on the left is equal to the number of columns in the matrix on the right.
                        For this reason, among others, matrix multiplication is not commutative (A*B is not B*A;
                        sometimes B*A is not even possible).</p><p>4x4 matrices are used in computer graphics to transform 3 or 4-dimensional
                        vectors from one space to another. Most kinds of linear transforms can be
                        represented with 4x4 matrices.</p></dd><dt><span class="glossterm">column-major, row-major</span></dt><dd class="glossdef"><p>These terms define the two ways in which a matrix can be stored as an
                        array of values. Column-major order means that, for an NxM matrix (columns x
                        rows), the first N values in the array are the first column (top-to-bottom),
                        the next N values are the second column, and so forth. In row-major order,
                        the first M values in the array are the first row (left-to-right), followed
                        by another M values for the second row, and so forth.</p></dd></dl></div>
    </div><a class="github-fork-ribbon left-top" href="https://github.com/paroj/gltut" title="Fork me on GitHub">Fork me on GitHub</a><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="Tut04%20In%20Review.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="Tutorial%2004.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="Tutorial%2005.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">In Review </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 5. Objects in Depth</td></tr></table></div></body></html>
