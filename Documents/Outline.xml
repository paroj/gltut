<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://docbook.org/xml/5.0/rng/docbookxi.rng" type="xml"?>
<?oxygen SCHSchema="http://docbook.org/xml/5.0/rng/docbookxi.rng"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude"
    version="5.0">
    <title>Outline</title>
    <para>This tutorial outline will describe the relationship between the various tutorials, as
        well as the expected order in which they appear.</para>
    <section>
        <title>Introduction</title>
        <section>
            <title>Hello, Triangle!</title>
            <para>The most basic of GL programs, this will draw a single solid triangle over a blank
                background.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>That 3D graphics is made of triangles.</para>
                </listitem>
                <listitem>
                    <para>The process of scan conversion.</para>
                </listitem>
                <listitem>
                    <para>The data pathway of OpenGL, from input vertex attributes to output
                        fragment data.</para>
                </listitem>
                <listitem>
                    <para>The absolute bare-minimum vertex buffer code.</para>
                </listitem>
                <listitem>
                    <para>The absolute bare-minimum vertex shader code.</para>
                </listitem>
                <listitem>
                    <para>The absolute bare-minimum fragment shader code.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Playing with Colors</title>
            <para>This tutorial puts colors on our triangle.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>gl_FragCoord and its values.</para>
                </listitem>
                <listitem>
                    <para>Vertex arrays/streams. A discussion of how vertex data gets passed
                        around.</para>
                </listitem>
                <listitem>
                    <para>Buffer objects. The containers for vertex data.</para>
                </listitem>
                <listitem>
                    <para>Multiple vertex attributes. Matching vertex attributes between the vertex
                        shader and the vertex array. Passing colors to OpenGL.</para>
                </listitem>
                <listitem>
                    <para>Interleaving vertex arrays. The colors should be interleaved with the
                        positions.</para>
                </listitem>
                <listitem>
                    <para>Inputs and outputs between GLSL stages.</para>
                </listitem>
                <listitem>
                    <para>Interpolation of the stage inputs/outputs.</para>
                </listitem>
            </itemizedlist>
            <para>Tutorial sub-files:</para>
            <orderedlist>
                <listitem>
                    <para>Use gl_FragCoord to calculate fragment colors based on the position of the
                        fragments. Use the moving triangle as a base.</para>
                </listitem>
                <listitem>
                    <para>Use multiple vertex arrays to send position and color data. Use a vertex
                        shader output/fragment shader input to pass the per-vertex colors
                        through.</para>
                </listitem>
            </orderedlist>
        </section>
    </section>
    <section>
        <title>Vertices and Positioning</title>
        <section>
            <title>OpenGL's Moving Triangle</title>
            <para>This tutorial has a triangle moving around on the screen.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>OpenGL Objects. They hold state, and you bind them to change state and to
                        render.</para>
                </listitem>
                <listitem>
                    <para>Uniform variables in the OpenGL Shading Language. How to set them in the
                        API and how to retrieve them in GLSL code.</para>
                </listitem>
                <listitem>
                    <para>Granularity in GLSL: input vs. uniform vs. constant. How often each
                        changes.</para>
                </listitem>
                <listitem>
                    <para>Basic arithmetic in GLSL. Vector-on-vector arithmetic.</para>
                </listitem>
                <listitem>
                    <para>The extent of the space output by a vertex shader (clip space).</para>
                </listitem>
                <listitem>
                    <para>Clipping and the Viewport.</para>
                </listitem>
                <listitem>
                    <para>Multi-buffering (SwapBuffers).</para>
                </listitem>
            </itemizedlist>
            <para>Tutorial sub-files:</para>
            <orderedlist>
                <listitem>
                    <para>Use BufferSubData to update the triangle's position manually.</para>
                </listitem>
                <listitem>
                    <para>Use uniforms and a vertex shader to move the triangle's position. The
                        position offset comes directly from the user.</para>
                </listitem>
                <listitem>
                    <para>Use a vertex shader that generates the position offset based solely on a
                        time from start.</para>
                </listitem>
                <listitem>
                    <para>Use the time value from the last example in the fragment shader to do some
                        color interpolation.</para>
                </listitem>
            </orderedlist>
        </section>
        <section>
            <title>Objects at Rest</title>
            <para>This tutorial shows a scene of objects, along with a recognizable ground plane.
                This should all be rendered with a perspective projection.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Matrices and matrix math. A basic overview of matrix mathematics.</para>
                </listitem>
                <listitem>
                    <para>Perspective projection. The math for making objects look like they're in a
                        3D world.</para>
                </listitem>
                <listitem>
                    <para>Matrices in GLSL, and vector/matrix operations thereupon.</para>
                </listitem>
                <listitem>
                    <para>World to clip transform. How to convert from objects in world-space to
                        clip-space.</para>
                </listitem>
                <listitem>
                    <para>Perspective-correct interpolation.</para>
                </listitem>
                <listitem>
                    <para>Viewport aspect ratio adjustment.</para>
                </listitem>
            </itemizedlist>
            <para>Tutorial sub-files:</para>
            <orderedlist>
                <listitem>
                    <para>Make a cube where each face has a different color. Place the cube to the
                        side of the viewing area. This shows what things are like in an orthographic
                        projection. Use backface culling to make it render correctly.</para>
                </listitem>
                <listitem>
                    <para>Have the same cube, but in our new world coordinates and projection. Do
                        the projection explicitly, by passing the projection variables to the shader
                        and having it do the computations per-vertex.</para>
                </listitem>
                <listitem>
                    <para>Same as above, except pass in a matrix uniform. Have the shader do a
                        matrix-multiply on that uniform.</para>
                </listitem>
                <listitem>
                    <para>Same as above, except generate a scaling value to represent the aspect
                        ratio based on the width/height of the window.</para>
                </listitem>
            </orderedlist>
        </section>
        <section>
            <title>Objects in Depth</title>
            <para>This tutorial shows a sequence of objects. Some are referenced from different
                objects. These are rendered in perspective, and some are overlapping.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>VAOs, multiple. These are a great example of OpenGL objects storing
                        state.</para>
                </listitem>
                <listitem>
                    <para>Indexed vertex arrays. Include mention of the fact that there is only one
                        index for all of the attributes.</para>
                </listitem>
                <listitem>
                    <para>glDrawElementsBaseVertex, as an optimization.</para>
                </listitem>
                <listitem>
                    <para>Depth buffers. How to use them to hide surfaces. Do not forget about
                        glDepthRange and the depth portion of the viewport transform.</para>
                </listitem>
                <listitem>
                    <para>Clipping. Show how things are clipped against the view frustum. Note that
                        clipping happens in <emphasis>clip-space</emphasis>, not NDC space. Thus,
                        the clipped vertices will <emphasis>never</emphasis> have a W of 0.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Objects in Motion</title>
            <para>This tutorial shows a scene with objects moving in their own coordinate system.
                This will include using the same mesh in different locations.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Object-local coordinates. Each object can have its own natural coordinate
                        space. Multiple instances of objects rendered using the same mesh.</para>
                </listitem>
                <listitem>
                    <para>Object-to-camera transform. How to compute the transformation from
                        object-space to camera-space. Handle scale, rotation, and
                        translation.</para>
                </listitem>
                <listitem>
                    <para>Composing multiple object-to-camera transformations. Deal with the
                        differences with regard to the order of transformations.</para>
                </listitem>
                <listitem>
                    <para>Handle object hierarchies with a matrix stack.</para>
                </listitem>
                <listitem>
                    <para>Gimbol Lock.</para>
                </listitem>
            </itemizedlist>
            <para>Tutorial sub-files:</para>
            <orderedlist>
                <listitem>
                    <para>Animated translations only.</para>
                </listitem>
                <listitem>
                    <para>Animated scale only. Also, have a model with negative scale, to show how
                        to change the axis orientation of a model.</para>
                </listitem>
                <listitem>
                    <para>Animated rotation only.</para>
                </listitem>
                <listitem>
                    <para>Transformation composition, via matrix multiplication.</para>
                </listitem>
                <listitem>
                    <para>Have objects composed of hierarchies of transformations. Animate these
                        transformations in motion.</para>
                </listitem>
                <listitem>
                    <para>Have multiple different object geometries, with their own individual
                        transforms. Animate the transforms. Objects have different programs attached
                        that have different fragment shaders (and possibly vertex shaders).</para>
                </listitem>
            </orderedlist>
        </section>
        <section>
            <title>World in Motion</title>
            <para>This tutorial has an animated camera moving through a scene containing moving
                objects and a recognizable floor plane.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Camera-space, as distinct from world and object-local. How to compute
                        camera-space, and build a sequence of transformations from object to clip
                        space.</para>
                </listitem>
                <listitem>
                    <para>Uniform Buffer Objects. Use multiple different programs, so have UBOs for
                        the shared data. Use std140 layout.</para>
                </listitem>
                <listitem>
                    <para>The dangers of having an explicit world space (precision problems with
                        large numbers).</para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>Basic Lighting</title>
        <section>
            <title>Lights on</title>
            <para>This tutorial has a scene with several animated objects and a floor, all lit by a
                directional and point light, with different colors.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Normals for vertices, and how these interact with faceted models.</para>
                </listitem>
                <listitem>
                    <para>Vertex attribute compression: normalized attributes, and doing
                        decompression in the shader.</para>
                </listitem>
                <listitem>
                    <para>Lighting models. How to compute diffuse reflectance based on a light
                        direction and normal. The importance of an ambient lighting term to model
                        incidental reflectance.</para>
                </listitem>
                <listitem>
                    <para>Directional lights.</para>
                </listitem>
                <listitem>
                    <para>Implementing lighting in a vertex shader for both directional and point
                        lights. Combining results from both kinds of lighting into a single
                        value.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Plane Lights</title>
            <para>This tutorial has a scene with a ground plane and an animated light moving over
                it.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Point lights.</para>
                </listitem>
                <listitem>
                    <para>Limitations of point lights and vertex-based lighting.</para>
                </listitem>
                <listitem>
                    <para>Implementing per-fragment lighting.</para>
                </listitem>
                <listitem>
                    <para>Talk about the artifact when lights get too close to the object. Talk
                        about why it happens (surface being planar and not circular).</para>
                </listitem>
                <listitem>
                    <para>Light attenuation.</para>
                </listitem>
                <listitem>
                    <para>Distances in alternate spaces and how to compensate.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Shininess</title>
            <para>This tutorial introduces ways to make an object look shiny. Specifically specular
                lighting and the Phong lighting model. There should be an animated light that shows
                this off.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>BDRFs: Lighting models that are a function of surface normal, angle to the
                        light, and angle to the camera.</para>
                </listitem>
                <listitem>
                    <para>The Phong specular lighting model. With both directional and point
                        lights.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Many Lights</title>
            <para>This tutorial creates a scene with multiple light sources in it.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>How to use multiple light sources. Particularly, looping in a
                        shader.</para>
                </listitem>
                <listitem>
                    <para>Separating the effects of multiple light sources.</para>
                </listitem>
                <listitem>
                    <para>Using arrays in shaders and UBOs.</para>
                </listitem>
                <listitem>
                    <para>Gamma correction.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Lies and Imposters</title>
            <para>This tutorial shows how to create a sphere imposter, complete with accurate depth.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Making up positions of objects out of whole cloth.</para>
                </listitem>
                <listitem>
                    <para>Fragment discard.</para>
                </listitem>
                <listitem>
                    <para>Fragment depth writes.</para>
                </listitem>
                <listitem>
                    <para>The fact that fake objects can be created out of just a triangle.</para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>Texturing</title>
        <section>
            <title>Textures are not Pictures</title>
            <para>This tutorial involves using a texture to define the specular value of an object
                at a certain point.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Perspective-correct interpolation of vertex attributes.</para>
                </listitem>
                <listitem>
                    <para>Texture objects. An OpenGL object that holds images.</para>
                </listitem>
                <listitem>
                    <para>Normalized texture coordinates. Vertex attributes that are used to apply a
                        texture to a surface.</para>
                </listitem>
                <listitem>
                    <para>Sampler objects.</para>
                </listitem>
                <listitem>
                    <para>The GLSL side of texturing. Samplers and texture functions in fragment
                        shaders.</para>
                </listitem>
                <listitem>
                    <para>Associating textures with programs. Sampler uniforms and texture image
                        units.</para>
                </listitem>
                <listitem>
                    <para>Using values from textures in lighting equations.</para>
                </listitem>
                <listitem>
                    <para>Animated texture coordinates.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>More Images is Better</title>
            <para>This tutorial shows a ground plane with a highly aliased texture (as the diffuse
                color). An animated camera shows off the aliasing. Then we apply mipmapping and
                anisotropic filtering to the surface to improve it.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Texture wrapping. How normalized texture coordinates outside of the [0, 1]
                        range are interpreted.</para>
                </listitem>
                <listitem>
                    <para>Texture filtering. How OpenGL computes inbetween values for fragments when
                        you sample a texture.</para>
                </listitem>
                <listitem>
                    <para>Texture aliasing. Where it comes from, and how to solve it.</para>
                </listitem>
                <listitem>
                    <para>Mipmap generation.</para>
                </listitem>
                <listitem>
                    <para>Mipmap filtering. How it works, and how to set it in OpenGL.</para>
                </listitem>
                <listitem>
                    <para>Texture isotropy. Show the over-filtering with regular mipmapping.</para>
                </listitem>
                <listitem>
                    <para>Anisotropic filtering. How it works and how to set it in OpenGL.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Climbing the Mountain</title>
            <para>This tutorial uses a height map and adjust vertex positions and normals to match
                it. The height map is a texture.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Internal image formats, particularly 1-channel textures.</para>
                </listitem>
                <listitem>
                    <para>Vertex texture accessing. How it differs from fragment textures
                        (mipmapping and such).</para>
                </listitem>
                <listitem>
                    <para>Constructing normals from the height field in the vertex shader.</para>
                </listitem>
                <listitem>
                    <para>Offset textures. Constructing normals from the texture map, using offsets
                        into the detailed bump map.</para>
                </listitem>
                <listitem>
                    <para>Texture space-based lighting. Transforming the light into the space of the
                        texture to do lighting. This requires binormal and tangent vectors.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Spot Lights</title>
            <para>Use a projected texture to imitate a spot light.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Projective texturing. The concept of it and the GLSL language
                        support.</para>
                </listitem>
                <listitem>
                    <para>Textures as light sources. The texel values are light intensity values,
                        not diffuse colors.</para>
                </listitem>
                <listitem>
                    <para>Using a global texture over a scene.</para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>Framebuffers</title>
        <section>
            <title>Ghostly Visage</title>
            <para>This tutorial involves a scene with some opaque and some transparent
                objects.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>What the alpha value of a color means. Specifically, that it means
                        whatever you want.</para>
                </listitem>
                <listitem>
                    <para>Framebuffer blending. The blend function, how it works, and how to change
                        it in OpenGL.</para>
                </listitem>
                <listitem>
                    <para>How blending interacts with depth writing and testing. Namely, that you
                        have to manually sort objects now: turn depth writes off and depth tests
                        on.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Many Lights, Revisited</title>
            <para>This tutorial creates a scene with multiple light sources in it.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>The problems with using loops in shaders.</para>
                </listitem>
                <listitem>
                    <para>Multipass rendering of the lights.</para>
                </listitem>
                <listitem>
                    <para>Create a reason to use different vertex shaders. Thus allowing us to
                        introduce <quote>invariant</quote> and the invariance guarantee.</para>
                </listitem>
                <listitem>
                    <para>Precision problems with multipass.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Video Camera</title>
            <para>This tutorial involves rendering a view of one scene to a texture used in a
                different location.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Framebuffer objects and renderbuffers. How to render to different
                        targets.</para>
                </listitem>
                <listitem>
                    <para>Viewport settings.</para>
                </listitem>
                <listitem>
                    <para>Rendering the same scene from multiple camera angles. Managing the data
                        for doing so.</para>
                </listitem>
                <listitem>
                    <para>Render to texture. Rendering to a texture and then using that texture as a
                        source for rendering elsewhere.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Selecting the Masses</title>
            <para>This tutorial creates a number of entities that all move around, on pre-defined
                paths, over a surface of bumpy terrain. They do not interact with the terrain. We
                then render projected selection circles onto the ground beneath them.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Projective texturing. How projecting a texture over a surface works
                        mathematically, and what support there is in the language.</para>
                </listitem>
                <listitem>
                    <para>Multi-pass rendering. Rendering geometry multiple times with a different
                        program/texture set. Not strictly necessary in this example, but it shows
                        how to do it if you need to.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>The Coming of Shadows</title>
            <para>This tutorial creates mountainous terrain, and then applies shadow mapping against
                a directional light. The light should animate to accentuate the effect.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Depth textures. Single-channel textures that take depth data from an
                        OpenGL rendering. Can be used as direct render targets.</para>
                </listitem>
                <listitem>
                    <para>Texture comparison modes. Changing how the filtering algorithm works so
                        that texture access compare to a given value, rather than simply sample from
                        a point. This includes shadow sampler usage.</para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>Advanced Lighting</title>
        <section>
            <title>Dynamic Lighting</title>
            <para>This tutorial takes a scene with directional lighting and shadows, with specular
                lighting on some of the objects (and an identifiable ground), and applies basic HDR
                to it.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Non-clamped color spaces. Noting that the [0, 1] range is an
                        approximation, and that light darkening is completely wrong.</para>
                </listitem>
                <listitem>
                    <para>16-bit floating-point values. Useful for blending and not taking up nearly
                        as much room/performance.</para>
                </listitem>
                <listitem>
                    <para>Floating-point render targets. Do not forget the hardware
                        limitations.</para>
                </listitem>
                <listitem>
                    <para>HDR techniques. How to reduce a floating-point texture to a [0, 1] range
                        color.</para>
                </listitem>
                <listitem>
                    <para>Light attenuation.</para>
                </listitem>
                <listitem>
                    <para>Why one should use HDR.</para>
                </listitem>
                <listitem>
                    <para>Multiple light sources and how to combine them.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Blooming</title>
            <para>This tutorial takes the previous scene and adds blooming of high powered
                lights.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Blooming. A multi-pass algorithm of operations over the same texture. All
                        done before reduction to the integer colorspace.</para>
                </listitem>
                <listitem>
                    <para>Introduce R11F_G11F_B10F as an optimization.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Mirror Mirror</title>
            <para>This tutorial has a skybox world with a shiny object and light source in it. The
                shiny object should reflect the world and have proper specular with the light
                source. It should still use HDR, but blooming is not required.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Skybox: Displays a static world around the object.</para>
                </listitem>
                <listitem>
                    <para>Cubemaps. Used to get the reflected color, as well as render the
                        skybox.</para>
                </listitem>
                <listitem>
                    <para>RGB9_E5 Texture format. The skybox should use this format. Compact
                        floating-point format with good precision and large range of values.</para>
                </listitem>
                <listitem>
                    <para>Properly combining lighting models. Adding lights from different sources
                        to achieve result.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Dark Shadows</title>
            <para>This tutorial has an animated point-light source and a world of objects, some
                animated. The point light should cast a shadow via cube-based shadow mapping.</para>
            <para>Concepts:</para>
            <itemizedlist>
                <listitem>
                    <para>Depth-formatted cube maps. Using cubemaps as depth comparison
                        textures.</para>
                </listitem>
                <listitem>
                    <para>Render to Cubemap, using 6 render targets (but one depth
                        renderbuffer).</para>
                </listitem>
                <listitem>
                    <para>Geometry shaders and layered rendering. These act as optimizations
                        (theoretically, at least).</para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>Twisty Objects, All Alike</title>
        <para>This tutorial involves rendering a lot of fairly simple animating objects. They all
            share the same texture. There should be a basic light in the scene.</para>
        <para>Concepts:</para>
        <itemizedlist>
            <listitem>
                <para>Instanced rendering. An optimization for rendering multiple objects of the
                    same kind.</para>
            </listitem>
            <listitem>
                <para>Buffer textures. Used for getting data up to the card.</para>
            </listitem>
            <listitem>
                <para>Buffer object streaming. Used for transferring the data efficiently.</para>
            </listitem>
            <listitem>
                <para>Instance arrays. Alternative to buffer textures.</para>
            </listitem>
        </itemizedlist>
    </section>
    <section>
        <title>Twisty Objects, All Different</title>
        <para>As above, only the objects have more per-instance data. Different textures and
            material parameters per-instance.</para>
        <para>Concepts:</para>
        <itemizedlist>
            <listitem>
                <para>Conditional logic in fragment shaders.</para>
            </listitem>
            <listitem>
                <para>Non-uniform control flow and Grad textures. Used to select between multiple
                    texture instances.</para>
            </listitem>
            <listitem>
                <para>Array textures. Used as a better means for selecting which texture to
                    use.</para>
            </listitem>
        </itemizedlist>
    </section>
    <section>
        <title>Functionality that needs tutorials</title>
        <glosslist>
            <glossentry>
                <glossterm>Depth Precision and Reverse Transform</glossterm>
                <glossdef>
                    <para>The issues with depth precision and reverse transform. Introduce fix where
                        you reverse camera Znear and Zfar.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>sRGB Colorspace</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Integral textures</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Radial fog</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>1:1 Pixel accurate texture rendering</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Procedural Textures</glossterm>
                <glossdef>
                    <para>How to do procedural textures, with proper filtering and so forth.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Debugging</glossterm>
                <glossdef>
                    <para>How to debug problems in OpenGL.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>More vertex attributes</glossterm>
                <glossdef>
                    <para>Might be shown off with skinning.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Non-Triangle Primitives</glossterm>
                <glossdef>
                    <para>This might also be a good place to show off primitive restart.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Conditional discard</glossterm>
                <glossdef>
                    <para>AKA: Alpha test. Also use pre-multiplied alpha.</para>
                    <para>This might be shown via rendering a tree or a chain-linked fence.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Pixel transfer</glossterm>
                <glossdef>
                    <para>Includes PBO for asynchronous delivery</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Compressed image formats</glossterm>
                <glossdef>
                    <para>Show these off.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Transform feedback</glossterm>
                <glossdef>
                    <para>This should be justified by having a large vertex shader with a good
                        quantity of vertices, as well as RTT. The feedback is an optimization: you
                        feedback to simplify things, then use the feedback data with special
                        shaders.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>2D in 3D</glossterm>
                <glossdef>
                    <para>Ortho projections and depth ranges.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Near/far clipping</glossterm>
                <glossdef>
                    <para>Some kind of example that shows this stuff off and how to fix it.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Z-fighting</glossterm>
                <glossdef>
                    <para>An example to show how it can happen.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Stencil buffer</glossterm>
                <glossdef>
                    <para>Something to show their utility.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>3D Textures</glossterm>
                <glossdef>
                    <para>Something to show their utility.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Multisampling</glossterm>
                <glossdef>
                    <para>Something to show the need for this.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Exact window pixel alignment</glossterm>
                <glossdef>
                    <para>Show how to do this in OpenGL.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Scissor box</glossterm>
                <glossdef>
                    <para>Something to show this feature off.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Flat Shading</glossterm>
                <glossdef>
                    <para>Show this off.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Early Depth Test</glossterm>
                <glossdef>
                    <para>Optimization.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>Invariance</glossterm>
                <glossdef>
                    <para>Using the <quote>invariant</quote> qualifier to ensure invariance across
                        shader programs.</para>
                </glossdef>
            </glossentry>
        </glosslist>
    </section>
</article>
